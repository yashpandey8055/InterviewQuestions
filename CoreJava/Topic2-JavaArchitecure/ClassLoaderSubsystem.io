JVM is an abstract virtual machine whose sole responsibility is to convert generated ByteCode to Machine code and execute it. 
JRE is the implementaion of JVM. The compiler compiles Java code into .class files (the bytecode) and these .class files are then loaded and executed by JVM. 

JVM architecture works with three main Subsystems -> 
A) Classloader Subsystem 
B) Runtime Data Area 
C) Execution Engine 

Java Virtual Machine Startup-> 
The Java Virtual Machine starts up by creating an initial class, which is specified in an implementation-dependent manner, using the bootstrap class loader ). The Java Virtual Machine then links the initial class, initializes it, and invokes the public class method void main(String[]). The invocation of this method drives all further execution. Execution of the Java Virtual Machine instructions constituting the main method may cause linking (and consequently creation) of additional classes and interfaces, as well as invocation of additional methods.

"Array classes do not have an external binary representation; they are created by the Java Virtual Machine rather than by a class loader."

A) Classloader Subsystem -> 
The class loader subsystem is responsible for loading , linking and initializing a class file when the class is referred for the first time. The loading , linking and initialising are the initial process which JVM commences as soon as the byte code is loaded into JVM for execution.

1) Loading -> This component handles loading class details from hardware system into JVM memory. It will load all the binary data like (methods , static variables , fully qualified class names) into the Method Area. "JVM immediately created an object of Java.lang.class into the heap" 
Therefore, in a nutshell, the loading process basically performs these three functions:

- Create a binary stream of data from the class file
- Parse the binary data according to the internal data structure
- Create an instance of java.lang.Class

There are three types of Classloaders available :
 a) Bootstrap classloader -> This classloader is responsible for loading class files from rt.jar and other classes in java.lang.* .
 b) Extension classloader -> This classloader is responsible for loading class from extension classpath (jdk/jre/lib/ext)
 c) Application/system classloader -> This classloaded is responsible for loading class from system classpath. 
 
 DELEGATE HIERARCHY MODEL -> The classloaded works in a delegation hierarchy model. 
 
 DELEGATION :
 a) Whenever JVM comes across a class, the JVM checks if the class is already loaded. if not , If the class is present in method area then JVM will conside the class  , but if its not , JVM requests for class from ClassLoader System. 
 b) Once the .class file is requested to be loaded , the request goes to Applicatiom/System classloader which delegates the request to Extension which further delegates to Bootstrap classloader. 
 c) The bootstrap loader tries to load the class and if its not found in any of java.lang packages or rt.jar , the request is extended to Extension classloader
 d) The Extension loader tries to load the class and if its not found in extension classpath , the request is extended to Applicatiom/System classloader 
 e) If the class is not found by Applicatiom/System class loaded, then it throws "ClassNotFoundException". 
 
 VISIBILITY : 
 The classes loaded by parent is visible to child class loader but vice versa is not true. 
 
 UNIQUENESS : 
 Class loaded by Parent classloader is not loaded by child class loader. 
 
2) Linking -> Linking is the component which performs linking of the class , Interface and superclasses. As this involves allocation of new data structures, this is where outofmemory is thrown if the memory goes out of proportion and it performs three important functions :
 a) Verification: Verification is the process of verifying the byte code of .class file. This is done by Bytecode verifier and if the byte code is not valid then an error of VerifyError is throw. This makes sure the bytecode obtained in loading process is a valid Java Bytecode
 b) Preparation : It is process of assigning memory to static variables and assign them default values.
 c) Resolution : All symbolic references that were now loaded into the method area in form of the runtime constant pool are resolved to actual types loaded by this JVM. If a symbolic reference can be resolved but results in a conflict of definitions, a IncompatibleClassChangeError is thrown. If a referenced class cannot be found, a NoClassDefFoundError is thrown which basically wraps a ClassNotFoundException that was thrown by the class loader attempting to load this referenced class. If a referenced class references itself, a ClassCircularityError is thrown. Resolution can happen in one of two flavors which is up to the implementors of the JVM 
 
3) Initialisation -> This is the process where all static variables are assigned their original values and static blocks are executed from parent class to child clas.  Initialization of a class or interface consists of executing the class or interface initialization method <clinit>

NOTES -> 
SYMBOLIC REFERENCES -> When a Java class is compiled, all references to variables and methods are stored in the class's constant pool as a symbolic reference. A symbolic reference is a logical reference not a reference that actually points to a physical memory location. The symbolic references are resolved in resolution phase. Constant Pool is a part of .class file that contains the constants which are needed to run the code. These constants includes , literals specified by programmers and symbolic references generated by compiler. These symbolic references are nothing but class, fields and methods referenced from code 
which JVM uses to link the class to other classes which code depends on.  (Used in linking process)
There is a constant pool inside every class. 


ClassNotFoundException Vs NoClassDefFoundError -> 
	ClassNotFoundException is a subtype of java.lang.Exception and it occurs when a class definition is not found. 
	This exception occurs mostly when Class is dynamically loaded with Class.forName() and class is not present in classpath. 

	NoClassDefFoundError -> It is the subtype of  java.lang.LinkageError which is an error if the class which code was using was present at compile time but somehow not present at runtime.  NoClassDefFoundError globally simply mean that the JVM tried to access at runtime something that according to the compiled code should exists, but does not actually exist (or is not in the classpath).